https://honey-push-30b.notion.site/Textbook-RSA-3e433f59f85844208adecc76230ccd0c 에서 사진 깨짐 없이 볼 수 있다.

# Textbook-RSA

![문제 파일 다운로드.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/170f9202-d8fd-46f1-a7a5-f5f6c8532459/문제_파일_다운로드.png)

드림이가 비밀 플래그를 가지고 있는 RSA 서버에서 플래그를 탈취하는 문제이다.

문제파일 다운로드를 통해 파일을 다운로드 받으면 [Challenge.py](http://Challenge.py)파일을 얻을 수 있다.

```python
#!/usr/bin/python3
from Crypto.Util.number import getStrongPrime, bytes_to_long, inverse

class RSA(object):
    def __init__(self):
        self.p = getStrongPrime(512)
        self.q = getStrongPrime(512) 
        self.N = self.p * self.q
        self.e = 0x10001
        self.d = inverse(self.e, self.N - self.p - self.q + 1)

    def encrypt(self, pt):
        return pow(pt, self.e, self.N)

    def decrypt(self, ct):
        return pow(ct, self.d, self.N)

rsa = RSA()
FLAG = bytes_to_long(open("flag", "rb").read())
FLAG_enc = rsa.encrypt(FLAG)

print("Welcome to dream's RSA server")

while True:
    print("[1] Encrypt")
    print("[2] Decrypt")
    print("[3] Get info")

    choice = input()

    if choice == "1":
        print("Input plaintext (hex): ", end="")
        pt = bytes_to_long(bytes.fromhex(input()))
        print(rsa.encrypt(pt))

    elif choice == "2":
        print("Input ciphertext (hex): ", end="")
        ct = bytes_to_long(bytes.fromhex(input()))
        if ct == FLAG_enc or ct > rsa.N:
            print("Do not cheat !")
        else:
            print(rsa.decrypt(ct))

    elif choice == "3":
        print(f"N: {rsa.N}")
        print(f"e: {rsa.e}")
        print(f"FLAG: {FLAG_enc}")

    else:
        print("Nope")
```

## RSA Class 분석

```python
class RSA(object):
    def __init__(self):
        self.p = getStrongPrime(512)
        self.q = getStrongPrime(512) 
        self.N = self.p * self.q
        self.e = 0x10001
        self.d = inverse(self.e, self.N - self.p - self.q + 1)

    def encrypt(self, pt):
        return pow(pt, self.e, self.N)

    def decrypt(self, ct):
        return pow(ct, self.d, self.N)
```

### init 함수

1. 변수 p에 512바이트 소수를 저장한다.
2. 변수 q에 512바이트 소수를 저장한다.
3. 변수 N은 q와 q를 곱한 값이다. (N=pq)
4. 변수 e는 0x10001이다. (10진수 기준 65,537)
5. 변수 d는 inverse 함수를 사용하는데 정확한 작동 구조는 모르겠지만 다음 식을 만족하는 d값을 찾아준다.

![d값.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f7d5e6c8-bd80-4de1-b945-9f841b661cc8/d값.png)

이 때 N=p*q이므로 

N-p-q+1= pq-p-q+1이다.

이 값을 p로 묶어주면

p(q-1)-(q-1)이고

(p-1)(p-1)이다.

즉 다음과 같은 식을 만족하는 d를 구한다.

![d값2.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/02790752-f5a8-4973-aaac-64cda86695c6/d값2.png)

### encrypt 함수(self,pt):

1. 매개변수 평문 pt를 e제곱한 후 N으로 나눈 나머지를 리턴한다.

![암호문.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dd92e03-e09c-4fa9-b529-c73148a47b3a/암호문.png)

### decrypt 함수

1. 매개변수 암호문 ct를 d로 제곱한후 N으로 나눈 나머지를 리턴한다.

![평문.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60394b1c-f676-4493-bcc9-7c5b27d0fe60/평문.png)

## 반복문 이전

```python
rsa = RSA()
FLAG = bytes_to_long(open("flag", "rb").read())
FLAG_enc = rsa.encrypt(FLAG)

print("Welcome to dream's RSA server")
```

1. rsa 객체를 선언
2. 드림이 서버에 저장된 FLAG를 읽어와 long형으로 가져온다.
3. long형으로 가져온 FLAG를 암호화한다.

## 반복문

```python
while True:
    print("[1] Encrypt")
    print("[2] Decrypt")
    print("[3] Get info")

    choice = input()

    if choice == "1":
        print("Input plaintext (hex): ", end="")
        pt = bytes_to_long(bytes.fromhex(input()))
        print(rsa.encrypt(pt))

    elif choice == "2":
        print("Input ciphertext (hex): ", end="")
        ct = bytes_to_long(bytes.fromhex(input()))
        if ct == FLAG_enc or ct > rsa.N:
            print("Do not cheat !")
        else:
            print(rsa.decrypt(ct))

    elif choice == "3":
        print(f"N: {rsa.N}")
        print(f"e: {rsa.e}")
        print(f"FLAG: {FLAG_enc}")

    else:
        print("Nope")
```

## [1] Encrypt 과정

사용자로 부터 받은 입력을 바이트단위로 받아 long으로 바꾼 결과를 출력한다.

이 때 입력받은 값을 bytes.fromhex()로 받는 것을 보면 hex형식으로 입력값을 받는것을 알 수 있다.

## [2] Decrypt 과정

사용자로 부터 암호문을 입력받아 long형으로 하여 복호화 한다.

이때 복호화할 암호문이 FLAG_enc나 N보다 크면 출력이 되지 않는다.

## [3] Get info 과정

다음과 같은 값을 알려준다. 

1. N(p*q)
2. e값 0x10001
3. 암호화된 FLAG값(암호문)

을 출력한다.

## 첫번째 시도

복호화를 하기 위해서는 d값과 N값이 필요하다. 이 때 d값을 구할 때는 p값과 q값 e값을 알아야 하는데 우리는 p와q를 곱한 pq값에서 p와 q값을 알 수 있다고 생각했다. 그래서 접속해서 N값과 암호화된 FLAG값을 받아왔다.

![접속정보 확인.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8080e96f-35b3-408e-b696-a0e7e2a0addb/접속정보_확인.png)

nc [host1.dreamhack.games](http://host1.dreamhack.games) 24378을 통해 접속한다.

![N값과 E값과 FLAG값.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/17435b0e-2fcc-47b8-a411-f5c3681d8f2d/N값과_E값과_FLAG값.png)

N: 107252318719587421205718203923818058537756043370290354050433173791932953185050722777024276439850583682041365624975564859725788711924687807737554371315659623473235450015577146123969227848285639365022573490462645181267532335548938625144351847559370844469284324798576990286863664221322269833808936721937931956111

e: 65537

FLAG: 65264410273719413692625723295715003989177103580093936591305983063377860115198036771969198542668550801083441067627467450792948740082323560700877282167589170505115406798846564799325384806966302576141955023858758940200499579056572619842304402538009321460516471400912268497985079999831605030824787117724277520147

## 두번째 시도

N값이 512바이트의 소수 2개를 곱한 것이라 그런지 너무 큰 값(309자리수)이 나와 이 값을 이루는 두 소수를 찾기에는 너무 오랜시간이 걸려서 다른 방법을 찾아봤다.

[https://xerxes-break.tistory.com/341](https://xerxes-break.tistory.com/341) 이 곳에서 힌트를 얻었다. [1][2]에서 내가 암호화와 복호화를 할 수 있는 기능을 준 이유는 같은 N값을 이용해 임의의 평문을 넣어 추가적인 암호문을 얻으라는 뜻이었다.

핵심은 같은 키로 생성된 서로 다른 암호문 두개를 곱하면 평문 두개의 곱을 암호화 한 것과 결과가 같다는 것이다.  

![곱셈에 대한 준동형사상 성질.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9bd284c-3f58-4730-b835-d53e8d4b2436/곱셈에_대한_준동형사상_성질.png)

위의 성질을 이용하게 되는데 

![곱셈에대한 준동형사상 성질 이용 공격.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b015c656-e7b8-418a-bff9-353903cd7de0/곱셈에대한_준동형사상_성질_이용_공격.png)

1. 암호문 C를 알고 있다.
2. 내가 임의의 평문 r을 암호화한 결과값에 암호문 C를 곱해 C’을 얻는다.
3. 이 C’을 복호화 하면 암호문C의 평문 M과 내가 만든 임의의 평문 r의 곱이 나온다.

우리는 암호문 C를 알고 있고 같은 키로 임의의 평문 을 암호화 및 복호화할 수 있으므로 위 과정을 거치면 된다. 

이 때 우리가 입력하는 값은 hex값이므로 11을 입력해줬다.

![11을 암호화 한 결과.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd98fb9a-44dd-4bcd-b86e-4fb5729119a7/11을_암호화_한_결과.png)

이제 11을 암호화 한 값은 아래와 같고

93140709984130644379694694189758738001709221506595943579034702530151096239600718845766645070334762806133066253280466872612177599837228324439280756914247089835686099844092483402381112584773593429566525388857644865429127519689756796646375372639024815614664550013307895011855718025846508492071867212395347304205

FLAG는 아래와 같다.  65264410273719413692625723295715003989177103580093936591305983063377860115198036771969198542668550801083441067627467450792948740082323560700877282167589170505115406798846564799325384806966302576141955023858758940200499579056572619842304402538009321460516471400912268497985079999831605030824787117724277520147

이제 이 두 값을 곱해준 다음 16진수로 만들어준다.(복호화 때도 hex값으로 넣어줘야 하므로) 계산을 해줬다.

```python
enc_r=93140709984130644379694694189758738001709221506595943579034702530151096239600718845766645070334762806133066253280466872612177599837228324439280756914247089835686099844092483402381112584773593429566525388857644865429127519689756796646375372639024815614664550013307895011855718025846508492071867212395347304205
Flag_enc=65264410273719413692625723295715003989177103580093936591305983063377860115198036771969198542668550801083441067627467450792948740082323560700877282167589170505115406798846564799325384806966302576141955023858758940200499579056572619842304402538009321460516471400912268497985079999831605030824787117724277520147

print(hex(enc_r*Flag_enc))

```

결과 값이 아래와 같이 나오는데 이 값을 decrypt 함수를 통해 복호화 해주면 내가 넣은 임의의 평문 11(hex)와 FLAG의 곱이 나올 것이다. 

0x3027359aa282905f4a10858fd9b06c98bed60a6b4a130f660aba454987e1ba56667f5aa9a7d9222cdac356b92599b36f5d7a92842599d2500495942fdd12c7782f6eb1bdb6700d0db0e49f69ba66021b5332c2df7c4bb3bd5e8962d54d1482e93096db87070d9e6a24bcfe87d30f8590531e35646ec11e2e753fd61e7ec16f99734e7c1a66d01b85f098180bceb4bcec828bd290c406607de2fabf597b1c05f7ddc3b1378498afbb4ee86491984fb7a43420b4377b9acaa90e67e25615a1731eebef0b682b8de091cdd68af0218c59aaf8eb10fcc61ac02287b8427feeab09aa339819d03408aa6aa59aae7a1206bf374f5b907787e96bd01ab487edcb02d8f7

이 값을 이제 복호화 하면 평문 *11(hex)이 나오겠지! 하며 넣어줬는데

![망함.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06c19abd-876c-4c44-a6e3-50c54eb38542/망함.png)

Do not cheat ! 가 떠버렸다..

## 세번째 시도

이 값이 FLAG_enc는 아니니까 문제는 N보다 커서 에러가 뜬건데 그래서 어떻게 해야 연산 결과 크기를 줄이되 결과가 달라지지 않을 수 있을지 고민을 했다.

암호문은 일단 기본적으로 mod 연산이기 때문에 암호문 C와 내가 원하는 값r을 암호화 한 식을 곱한걸 mod N을 통해 다시 크기를 작게 해줘도 결과가 같지 않을까? 라는 생각을 했다. 

그래서 새롭게 다시 연결하여 해봤다.

N: (N의 값) 127172276151071615562092964670208338081717859311608101824127623012889039496451291197428498622495053863141838823747050084056028335125999212819303277466330863142843529344477936284082680718704359218650009980367410355328777739999350365062415755128970178663874697213901962821026353347191935770381233362069159672311

e: 65537

FLAG: (암호문) 57173535670098961412965542499722757855677473463309083979858771146649767599946017076135663240038995470568101091029906013894453390852393273876516361339317424407777749558136291477939241322935028567363659152133695762911373552408902682440298815759074203475877641099122217469647190775922761309828921941225450630829

Input plaintext (hex): 02 (임의의 값 2로 암호화 한 값)
16448917643784739435320449720369147200840636280871536587179749786544303254567662421820842446783191207572054529823739426637624296845866532827085552957515635271929460946987039155477704857107504441331995467449630436013932636103940705093483594430498649158157738911830808932386562175099148693894452596306399420030

```
N=127172276151071615562092964670208338081717859311608101824127623012889039496451291197428498622495053863141838823747050084056028335125999212819303277466330863142843529344477936284082680718704359218650009980367410355328777739999350365062415755128970178663874697213901962821026353347191935770381233362069159672311

e=65537

enc_r=16448917643784739435320449720369147200840636280871536587179749786544303254567662421820842446783191207572054529823739426637624296845866532827085552957515635271929460946987039155477704857107504441331995467449630436013932636103940705093483594430498649158157738911830808932386562175099148693894452596306399420030
Flag_enc=57173535670098961412965542499722757855677473463309083979858771146649767599946017076135663240038995470568101091029906013894453390852393273876516361339317424407777749558136291477939241322935028567363659152133695762911373552408902682440298815759074203475877641099122217469647190775922761309828921941225450630829

result=pow(enc_r*Flag_enc,1,N)

print(hex(result))
```

result값은0x3801270b9160f148751d24ed43979e17335af90fa29ee6505bccd2557403acf79be950372b596202e078da6314cdd5a36f1969e9037cce8f67cb5981cd6e9acf5ef1cfc0023625703d9fb79ff70223572373d3e42c729b97cb0fc331cc656a6c1b21543cac8157c3c8e64c99ad2097b3337ca781a9c0dc4535658781a26b8699 

이 나온다.

그래서 이 값을 복호화 해주면

Input ciphertext (hex): 3801270b9160f148751d24ed43979e17335af90fa29ee6505bccd2557403acf79be950372b596202e078da6314cdd5a36f1969e9037cce8f67cb5981cd6e9acf5ef1cfc0023625703d9fb79ff70223572373d3e42c729b97cb0fc331cc656a6c1b21543cac8157c3c8e64c99ad2097b3337ca781a9c0dc4535658781a26b8699

결과 값으로 아래와 같은 결과가 나온다.
265303025271760754782762668660255715813910508769429152493707039977108929146371416679674

이 값은 이론상 FLAG값과 내가 넣었던 임의의 값 2가 곱해진 값이므로 2를 나누어주면

```
print(hex(265303025271760754782762668660255715813910508769429152493707039977108929146371416679674//2))
```

0x44487b36363233633333626539306363323737323864346563373238373738353939327d 

결과값이 나온다. 이 값을 16진수 아스키 코드 변환기에 넣어주면

![16진수 변환.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf41bdef-2ce8-43f8-ade6-598544a81f97/16진수_변환.png)

DH가 나오는 걸로 봐서 FLAG 값을 제대로 획득 했음을 알 수 있다.
